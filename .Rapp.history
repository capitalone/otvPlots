test()
test()
test()
test()
test()
test()
test()
test()
testData[, weight]
sample(1:N, N, p=(.05, .95))
sample(1:N, N)
sample(1:100, 100)
sample(1:100, 100)[1:10]
idx = sample(1:100, 100)[1:10]
testData[idx, weight := NA]
testData
out <- OrderByR2(dataFl = testData, #
	dateNm = "date", buildTm = NULL, weightNm = NULL, kSample = NULL)
cntnsVars <- names(Filter(is.cntns, testData))
dscrtVars <- names(Filter(is.dscrt, testData))
expect_equal(length(out), length(cntnsVars) + length(dscrtVars))#
	cntnsOrder <- match(cntnsVars, out)#
	dscrtOrder <- match(dscrtVars, out)#
	#testing that all numeric variables appear before discrete#
	expect_lt(max(cntnsOrder), min(dscrtOrder))#
	#testing that all discrete variables appear in order#
	expect_equal(order(dscrtOrder), 1:length(dscrtOrder))#
	#testing that numeric variables appear in order#
	rSq1 <- CalcR2(out[1] , dataFl = testData, dateNm = "date", weightNm = "weight", imputeValue = NULL)#
	rSq2 <- CalcR2(out[2] , dataFl = testData, dateNm = "date", weightNm = "weight", imputeValue = NULL)
out
test()
test()
test()
load_all()
test()
test()
testData
myVar = "balance"
dataFl = testData
dateNm = "date"
imputeValue = 0
w <- dataFl[[weightNm]]
w
wIdx = w[is.na(w)]
wIdx
wIdx = is.na(w)
wIdx
which(wIdx)
wIdx = which(is.na(w))
y <- dataFl[[myVar]]
y
y[is.na(y)] <- imputeValue
x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))
x
xIdx <- x[is.na(x[,2])]
xIdx
xwIdx = unique(c(xIdx, wIdx))
y
y[xwIdx] <- NULL
xwIdx
y[xwIdx]
wIdx
xIdx
wIdx = which(is.na(w))
xIdx <- which(is.na(x[, 2]))
xwIdx = unique(c(xIdx, wIdx))
xwIdx
y[xwIdx]
y[xwIdx] <- NULL
y[-c(xwIdx)]
setdiff(y, y[-c(xwIdx)])
load_all()
load_all()
test()
load_all()
test()
y <- dataFl[[myVar]]
y
if (!is.null(imputeValue)) {#
    	y[is.na(y)] <- imputeValue#
	} else {#
		yIdx <- which(is.na(y))#
	}
y
yIdx
load_all()
test()
y <- dataFl[[myVar]]
if (!is.null(imputeValue)) {#
    	y[is.na(y)] <- imputeValue#
    	yIdx = c()#
	} else {#
		yIdx <- which(is.na(y))#
	}
yIdx
if (!is.null(weightNm)) {#
      w <- dataFl[[weightNm]]#
      wIdx <- which(is.na(w))#
      wIdx = unique(c(yIdx, wIdx))#
    }
wIdx
x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))#
    xIdx <- which(is.na(x[, 2]))
xIdx
load_all()
test()
y <- dataFl[[myVar]]#
  	# if imputeValue is available, we will impute everywhere Y is missing#
    if (!is.null(imputeValue)) {#
    	y[is.na(y)] <- imputeValue#
    	yIdx = c()#
	} else {#
		yIdx <- which(is.na(y))#
	}#
#
	# We perform casewise deletion anywhere X, Y or W (if not null) is missing#
    if (!is.null(weightNm)) {#
      w <- dataFl[[weightNm]]#
      wIdx <- which(is.na(w))#
      wIdx = unique(c(yIdx, wIdx))#
    }
x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))#
    xIdx <- which(is.na(x[, 2]))#
    if (!is.null(weightNm)) {#
  		xIdx <- unique(c(xIdx, wIdx))#
    	w <- w[-c(wIdx)]#
    } #
    y <- y[-c(xIdx)]#
    x <- x[-c(xIdx),]
w
x
y
length(w)
length(y)
length(x)
dim(x)
if (is.null(weightNm)) {#
      mod <- lm.fit(x = x, y = y)#
      r2  <- 1 - sum(mod$resid ^ 2) / sum( (y - mean(y) ^ 2))#
    } else {#
      mod <- lm.wfit(x = x, y = y, w = w)#
      r2  <- 1 - sum(w * #
                       mod$resid ^ 2) / sum(w * (y - Hmisc::wtd.mean(y, w)) ^ 2)#
    }
r2
imputeValue = NULL
y <- dataFl[[myVar]]#
  	# if imputeValue is available, we will impute everywhere Y is missing#
    if (!is.null(imputeValue)) {#
    	y[is.na(y)] <- imputeValue#
    	yIdx = c()#
	} else {#
		yIdx <- which(is.na(y))#
	}#
#
	# We perform casewise deletion anywhere X, Y or W (if not null) is missing#
    if (!is.null(weightNm)) {#
      w <- dataFl[[weightNm]]#
      wIdx <- which(is.na(w))#
      wIdx = unique(c(yIdx, wIdx))#
    }    #
    x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))#
    xIdx <- which(is.na(x[, 2]))#
    if (!is.null(weightNm)) {#
  		xIdx <- unique(c(xIdx, wIdx))#
    	w <- w[-c(wIdx)]#
    } #
    y <- y[-c(xIdx)]#
    x <- x[-c(xIdx),]#
    if (is.null(weightNm)) {#
      mod <- lm.fit(x = x, y = y)#
      r2  <- 1 - sum(mod$resid ^ 2) / sum( (y - mean(y) ^ 2))#
    } else {#
      mod <- lm.wfit(x = x, y = y, w = w)#
      r2  <- 1 - sum(w * #
                       mod$resid ^ 2) / sum(w * (y - Hmisc::wtd.mean(y, w)) ^ 2)#
    }
r2
y
CalcR2 <- function(myVar, dataFl, dateNm, weightNm = NULL, imputeValue = NULL) {#
  message("Calculating R2 of ", myVar)#
  if (sum(!is.na(dataFl[[myVar]])) < 2) {#
    return(Inf)#
    # if kSample is not null, then we need to recheck that the subsample is not #
    # all missing. If there are less than 2 numeric values left after sampling #
    # we can't calculate R2#
  } else {#
  	y <- dataFl[[myVar]]#
  	# if imputeValue is available, we impute everywhere Y is missing#
    if (!is.null(imputeValue)) {#
    	y[is.na(y)] <- imputeValue#
    	yIdx = c()#
	} else {#
		yIdx <- which(is.na(y))#
	}#
#
	# We perform casewise deletion anywhere X, Y or W (if not null) is missing#
    if (!is.null(weightNm)) {#
      w <- dataFl[[weightNm]]#
      wIdx <- which(is.na(w))#
      wIdx = unique(c(yIdx, wIdx))#
    }    #
    x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))#
    xIdx <- which(is.na(x[, 2]))#
    if (!is.null(weightNm)) {#
  		xIdx <- unique(c(xIdx, wIdx))#
    	w <- w[-c(wIdx)]#
    } #
    y <- y[-c(xIdx)]#
    x <- x[-c(xIdx),]#
    if (is.null(weightNm)) {#
      mod <- lm.fit(x = x, y = y)#
      r2  <- 1 - sum(mod$resid ^ 2) / sum( (y - mean(y) ^ 2))#
    } else {#
      mod <- lm.wfit(x = x, y = y, w = w)#
      r2  <- 1 - sum(w * #
                       mod$resid ^ 2) / sum(w * (y - Hmisc::wtd.mean(y, w)) ^ 2)#
    }#
    return(r2)#
  }#
}
CalcR2("balance", testData, "date", "weight", NULL)
CalcR2("age", testData, "date", "weight", NULL)
data(bankData)
PrepData(bankData, dateNm = "date", dateGp = "months", dateGpBp = "quarters")
OrderByR2(bankData, dateNm = "date")
dataFl = bankData
dateNm = "date"
buildTm = NULL; weightNm = NULL; #
                     kSample = 50000
buildTm <- switch(as.character(length(buildTm)), "2" = as.IDate(buildTm),#
    "3" = as.IDate(buildTm[1:2], buildTm[3]), #
    # avoid inheritence as list using [[]]#
    dataFl[c(1, .N), dateNm, with = FALSE][[1]])
num_vars <- names(Filter(is.cntns, dataFl))
cat_vars <- names(Filter(is.dscrt, dataFl))
length(num_vars)
r2 <- vapply(num_vars, CalcR2, #
                dataFl = dataFl[buildTm[1] <= get(dateNm) & #
                                  get(dateNm) <= buildTm[2], ][#
                                    sample(.N, min(.N, kSample))], #
                dateNm = dateNm, weightNm = weightNm, imputeValue = NULL, #
                numeric(1))
CalcR2(myVar = "age",dataFl = dataFl[buildTm[1] <= get(dateNm) & #
                                  get(dateNm) <= buildTm[2], ][#
                                    sample(.N, min(.N, kSample))], #
                dateNm = dateNm, weightNm = weightNm, imputeValue = NULL)
CalcR2(myVar = "age",dataFl =dataFl, #
                dateNm = dateNm, weightNm = weightNm, imputeValue = NULL)
CalcR2(myVar = "age",dataFl =dataFl, #
                dateNm = dateNm, weightNm = "weight", imputeValue = NULL)
CalcR2(myVar = "age",dataFl =dataFl, #
                dateNm = dateNm, weightNm = NULL, imputeValue = NULL)
CalcR2("balance", testData, "date", NULL, NULL)
load_all()
test()
CalcR2("balance", testData, "date", NULL, NULL)
myVar="balance"
dataFl = testData
dateNm = "date"
weightNm = NULL
imputeValue = NULL
y <- dataFl[[myVar]]
yIdx <- which(is.na(y))
x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))
xIdx <- which(is.na(x[, 2]))
yIdx <- unique(c(xIdx, yIdx))
y <- y[-c(yIdx)]
x <- x[-c(yIdx),]
x
y
y <- dataFl[[myVar]]
yIdx <- which(is.na(y))
yIdx
x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))
y
x
xIdx <- which(is.na(x[, 2]))
xIdx
yIdx <- unique(c(xIdx, yIdx))
yIdx
y
y <- y[-c(yIdx)]
y
load_all()
test()
test()
test()
test()
testData[idx2, date := NA]
idx2 = sample(1:100, 100)[1:10]
testData[idx2, date := NA]
test()
test()
test()
load_all()
test()
load("testData.rda")#
testData = setDT(testData)
test()
test()
test()
test()
out <- OrderByR2(dataFl = testData, #
	dateNm = "date", buildTm = NULL, weightNm = NULL, kSample = NULL)#
	cntnsVars <- names(Filter(is.cntns, testData))#
	dscrtVars <- names(Filter(is.dscrt, testData))
testData
out <- OrderByR2(dataFl = testData, #
	dateNm = "date", buildTm = NULL, weightNm = NULL, kSample = NULL)
out <- OrderByR2(dataFl = testData, #
	dateNm = "date", buildTm = NULL, weightNm = "weight", kSample = NULL)
out <- OrderByR2(dataFl = testData, #
	dateNm = "date", buildTm = NULL, weightNm = NULL, kSample = NULL)
traceback()
load_all()
test()
testData
testData <- testData[, .(age, weight, date)]
testData
load("../testthat/testData.rda")
load("tests/testthat/testData.rda")
testData <- setDT(testData)
testData <- testData[, .(age, weight, date)]
testData
ans.R2 <- lm(age~date)$r.squared
ans.R2 <- lm(age~date, data=testData)$r.squared
expect_equal(test.R2, ans.R2)
test.R2 <- CalcR2("age", testData, "date", weightNm = NULL, imputeValue = NULL)
testData <- setDT(testData)
testData <- testData[, .(age, weight, date)]
testData
test.R2 <- CalcR2("age", testData, "date", weightNm = NULL, imputeValue = NULL)
load_all()
test.R2 <- CalcR2("age", testData, "date", weightNm = NULL, imputeValue = NULL)
myVar = "age"
dataFl = testData
dateNm = "date"
weightNm = NULL
imputeValue=NULL
y <- dataFl[[myVar]]#
  	# if imputeValue is available, we impute everywhere Y is missing#
    if (!is.null(imputeValue)) {#
    	y[is.na(y)] <- imputeValue#
    	yIdx = c()#
	} else {#
		yIdx <- which(is.na(y))#
	}
y
yIdx
if (!is.null(weightNm)) {#
      w <- dataFl[[weightNm]]#
      wIdx <- which(is.na(w))#
      yIdx = unique(c(yIdx, wIdx))#
    }
x <- cbind(1, as.matrix(as.numeric(dataFl[[dateNm]]), ncol = 1))#
    xIdx <- which(is.na(x[, 2]))#
    yIdx <- unique(c(xIdx, yIdx))
x
yIdx
xIdx
if (length(yIdx) > 0) {#
	  if (!is.null(weightNm)) {#
    		w <- w[-c(yIdx)]#
   	  } #
      y <- y[-c(yIdx)]#
      x <- x[-c(yIdx),]#
    }
y
x
xIdx
yIdx
if (is.null(weightNm)) {#
      mod <- lm.fit(x = x, y = y)#
      r2  <- 1 - sum(mod$resid ^ 2) / sum( (y - mean(y) ^ 2))#
    } else {#
      mod <- lm.wfit(x = x, y = y, w = w)#
      r2  <- 1 - sum(w * #
                       mod$resid ^ 2) / sum(w * (y - Hmisc::wtd.mean(y, w)) ^ 2)#
    }
r2
test.R2 <- CalcR2("age", testData, "date", weightNm = NULL, imputeValue = NULL)
mod <- lm.fit(x = x, y = y)
r2  <- 1 - sum(mod$resid ^ 2) / sum( (y - mean(y) ^ 2))
r2
yIdx <- which(is.na(y))
yIdx
xIdx <- which(is.na(x[, 2]))
yIdx <- unique(c(xIdx, yIdx))
length(yIdx)
is.null(weightNm)
load_all()
test()
test()
load("tests/testthat/testData.rda")
testData <- setDT(testData)
testData <- testData[, .(age, weight, date)]
testData
test.R2 <- CalcR2("age", testData, "date", weightNm = NULL, imputeValue = NULL)
test.R2
ans.R2 <- lm(age~date, data=testData)$r.squared
ans.R2
ans.R2 <- lm(age~date, data=testData)
ans.R2
str(ans.R2)
ans.R2 <- summary(lm(age~date, data=testData))$r.squared
ans.R2
ans.R2 <- summary(lm(age~date, weight="weight", data=testData))$r.squared
testData
ans.R2 <- summary(lm(age~date, weight=weight, data=testData))$r.squared
ans.R2
test.R2 <- CalcR2("age", testData, "date", weightNm = "weight", imputeValue = NULL)
test.R2
test.R2 <- CalcR2("age", testData, "date", weightNm = "weight", imputeValue = NULL)#
	ans.R2 <- summary(lm(age~date, weight=weight, data=testData))$r.squared#
	expect_equal(test.R2, ans.R2)
sampl.int(1:100, 10)
sample.int(1:100, 10)
?sample.int
sample.int(100, 10)
test()
test()
